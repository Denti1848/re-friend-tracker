import { __decorate } from 'tslib';
import { Input, Output, ViewChild, Component, ElementRef, HostListener, Directive, ViewContainerRef, ComponentFactoryResolver, NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpEventType, HttpResponse, HttpParams, HttpRequest, HttpClient, HttpClientModule } from '@angular/common/http';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import * as momentImported from 'moment';
import { BsDatepickerModule } from 'ngx-bootstrap/datepicker';
import { TooltipModule } from 'ngx-bootstrap/tooltip';
import { Subject } from 'rxjs';
import { debounceTime } from 'rxjs/operators';

class FormField {
    constructor(form, translationService) {
        this.form = form;
        this.translationService = translationService;
    }
    getForm() {
        return this.form;
    }
    get height() {
        return this._height;
    }
    set height(value) {
        this._height = value;
    }
    get visible() {
        return this._visible;
    }
    set visible(value) {
        this._visible = value;
    }
    get width() {
        return this._width;
    }
    set width(value) {
        this._width = value;
    }
    get newRow() {
        return this._newRow;
    }
    set newRow(value) {
        this._newRow = value;
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value;
    }
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = value;
    }
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
    }
    get labelVisible() {
        return this._labelVisible;
    }
    set labelVisible(value) {
        this._labelVisible = value;
    }
    isReadonly() {
        return this.readonly;
    }
    fromJson(modelFormField) {
        this.visible = true;
        if (modelFormField["visible"] != null) {
            this.visible = modelFormField["visible"];
        }
        this.labelVisible = true;
        if (modelFormField["labelVisible"] != null) {
            this.labelVisible = modelFormField["labelVisible"];
        }
        this.width = 1;
        if (modelFormField["width"] != null) {
            this.width = modelFormField["width"];
        }
        this.newRow = false;
        if (modelFormField["newRow"] != null) {
            this.newRow = modelFormField["newRow"];
        }
        this.required = false;
        if (modelFormField["required"] != null) {
            this.required = modelFormField["required"];
        }
        this.readonly = false;
        if (modelFormField["readonly"] != null) {
            this.readonly = modelFormField["readonly"];
        }
        this.id = modelFormField["id"];
        this.name = this.translationService.getText(modelFormField.name);
        this.type = modelFormField.type;
        this.height = modelFormField["height"];
    }
}

class ValueField extends FormField {
    constructor() {
        super(...arguments);
        this._isInitialValueSet = false;
        this._created = false;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    setValue(value) {
        this._value = value;
    }
    get created() {
        return this._created;
    }
    set created(value) {
        this._created = value;
    }
    isReadonly() {
        return this.readonly;
    }
    get isInitialValueSet() {
        return this._isInitialValueSet;
    }
    set isInitialValueSet(value) {
        this._isInitialValueSet = value;
    }
    fromJson(modelFormField) {
        super.fromJson(modelFormField);
        if (modelFormField["value"] != null) {
            this.setValue(modelFormField["value"]);
        }
    }
}

let FileUploadComponent = class FileUploadComponent {
    constructor(http) {
        this.http = http;
        this.dragActive = false;
    }
    onDropFile(event) {
        this.dragActive = false;
        event.preventDefault();
        this.uploadFile(event.dataTransfer.files);
    }
    onDragOverFile(event) {
        this.dragActive = true;
        event.stopPropagation();
        event.preventDefault();
    }
    onDragLeave() {
        this.dragActive = false;
    }
    selectFile(event) {
        this.uploadFile(event.target.files);
    }
    uploadFile(files) {
        if (files.length === 0) {
            console.log("No file selected!");
            return;
        }
        // check if file limit is exceeded
        if (!this.field.checkFileLimit(files.length)) {
            this.resetFileUploadElement();
            return;
        }
        // check file sizes
        if (!this.field.checkFileSize(files)) {
            this.resetFileUploadElement();
            return;
        }
        // upload submitted files
        Array.from(files).forEach((file) => {
            this.doUpload(this.field.getForm().getApp().getBackendUrl() + this.field.url, file)
                .subscribe(event => {
                if (event.type === HttpEventType.UploadProgress) {
                    const percentDone = Math.round(100 * event.loaded / event.total);
                    let uploadFile = this.field.findCurrentUpload(file.name);
                    if (uploadFile == null) {
                        uploadFile = this.addNewPathFile(file);
                    }
                    uploadFile.uploadProgress = percentDone;
                }
                else if (event instanceof HttpResponse) {
                    let uploadFile = this.field.findCurrentUpload(file.name);
                    if (uploadFile == null) {
                        uploadFile = this.addNewPathFile(file);
                    }
                    const key = new PathFileKey(event.body["key"]["key"], event.body["key"]["name"]);
                    uploadFile.key = key;
                    uploadFile.uploadFinished = true;
                    uploadFile.uploadSuccessful = true;
                    this.field.updateRequiredStatus();
                }
            }, (err) => {
                console.log("Upload Error:", err);
                const uploadFile = this.field.findCurrentUpload(file.name);
                if (uploadFile) {
                    uploadFile.sizeString = "Error";
                    uploadFile.uploadFinished = true;
                }
                else {
                    console.log("error: file should exist (" + file.name + ")");
                }
                this.resetFileUploadElement();
            }, () => {
                this.resetFileUploadElement();
            });
        });
    }
    addNewPathFile(file) {
        const uploadFile = new PathFile();
        uploadFile.name = file.name;
        uploadFile.size = file.size;
        uploadFile.sizeString = this.field.getReadableFileSizeString(file.size);
        uploadFile.active = true;
        this.field.value.push(uploadFile);
        this.field.sortValues();
        return uploadFile;
    }
    resetFileUploadElement() {
        const count = this.field.value.reduce((acc, cur) => !cur.uploadFinished ? ++acc : acc, 0);
        if (count === 0) {
            this.fileInputReference.nativeElement.value = "";
        }
    }
    doUpload(url, file) {
        const formData = new FormData();
        formData.append("upload", file);
        const params = new HttpParams();
        const options = {
            params: params,
            reportProgress: true,
        };
        const req = new HttpRequest("POST", url, formData, options);
        return this.http.request(req); // <any> fixes TS2719
    }
};
FileUploadComponent.ctorParameters = () => [
    { type: HttpClient }
];
__decorate([
    Input("field"),
    Output("field")
], FileUploadComponent.prototype, "field", void 0);
__decorate([
    ViewChild("fileInput", { static: true })
], FileUploadComponent.prototype, "fileInputReference", void 0);
FileUploadComponent = __decorate([
    Component({
        selector: "path-file-upload",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\" [class.file-upload-drop]=\"dragActive\"\r\n     (drop)=\"onDropFile($event)\" (dragleave)=\"onDragLeave()\" (dragover)=\"onDragOverFile($event)\">\r\n    <table class=\"table\">\r\n        <thead>\r\n        <tr>\r\n            <td class=\"col-md-7\">File Name</td>\r\n            <td class=\"col-md-2\">Size</td>\r\n            <td class=\"col-md-3\"></td>\r\n        </tr>\r\n        </thead>\r\n        <tbody>\r\n        <ng-container *ngFor=\"let file of field.value; let index = index\">\r\n            <tr *ngIf=\"file.active\">\r\n                <td class=\"col-md-7\"><a href=\"#\" (click)=\"field.download(file.key)\">{{file.name}}</a></td>\r\n                <td class=\"col-md-2\">{{file.sizeString}}</td>\r\n                <td class=\"col-md-3\" align=\"right\">\r\n                    <a *ngIf=\"file.uploadFinished\" href=\"#\" (click)=\"field.remove(index, file.key)\">Remove</a>\r\n                    <div *ngIf=\"!file.uploadFinished\" class=\"progress\">\r\n                        <div class=\"progress-bar\" role=\"progressbar\" [style.width.%]=\"file.uploadProgress\"\r\n                             [attr.aria-valuenow]=\"file.uploadProgress\" aria-valuemin=\"0\" aria-valuemax=\"100\">\r\n                            <span class=\"sr-only\">{{file.uploadProgress}}% Complete</span>\r\n                        </div>\r\n                    </div>\r\n                </td>\r\n            </tr>\r\n        </ng-container>\r\n        </tbody>\r\n    </table>\r\n    <div class=\"form-group\">\r\n        <input type=\"file\" class=\"form-control-file\" (change)=\"selectFile($event)\" placeholder=\"Upload file\"\r\n               [multiple]=\"field.multiple\" accept=\"{{field.acceptedFileTypes.join(', ')}}\"\r\n               [disabled]=\"field.isReadonly()\"\r\n               [required]=\"field.fileUploadRequired\" #fileInput>\r\n    </div>\r\n</div>\r\n"
    })
], FileUploadComponent);
class FileUploadField extends ValueField {
    constructor(form, translationService) {
        super(form, translationService);
        this._multiple = true;
        this._acceptedFileTypes = [];
        this._fileLimit = 0;
        this._singleFileSizeLimit = 0;
        this._allFilesSizeLimit = 0;
        this.value = [];
        this._acceptedFileTypes.push("*.*");
        this.updateRequiredStatus();
    }
    setValue(value) {
        const files = [];
        for (const item of value) {
            const file = Object.assign(new PathFile(), item);
            file.key = Object.assign(new PathFileKey(null, null), item.key);
            files.push(file);
        }
        this.sortValues();
        super.setValue(files);
        this.updateRequiredStatus();
    }
    sortValues() {
        this.value.sort((a, b) => a.name.localeCompare(b.name));
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = value;
    }
    get acceptedFileTypes() {
        return this._acceptedFileTypes;
    }
    set acceptedFileTypes(value) {
        this._acceptedFileTypes = value;
    }
    get fileUploadRequired() {
        return this._fileUploadRequired;
    }
    get fileLimit() {
        return this._fileLimit;
    }
    get singleFileSizeLimit() {
        return this._singleFileSizeLimit;
    }
    get allFilesSizeLimit() {
        return this._allFilesSizeLimit;
    }
    remove(index, key) {
        if (key) {
            const file = this.find(key);
            if (file) {
                file.active = false;
            }
            this.updateRequiredStatus();
        }
        else {
            this.value.splice(index, 1);
        }
    }
    find(key) {
        for (const file of this.value) {
            if (file.key.equals(key)) {
                return file;
            }
        }
        return null;
    }
    findCurrentUpload(name) {
        for (const file of this.value) {
            if (file.name === name && !file.uploadFinished) {
                return file;
            }
        }
        return null;
    }
    updateRequiredStatus() {
        let uploadInProgressCount = 0;
        let uploadSuccessfulCount = 0;
        this.value.forEach((file) => {
            if (file.active && !file.uploadFinished) {
                uploadInProgressCount++;
            }
            if (file.active && file.uploadSuccessful) {
                uploadSuccessfulCount++;
            }
        });
        let newStatus = false;
        if (uploadInProgressCount > 0) {
            // always required if upload in progress
            newStatus = true;
        }
        else if (this.required && uploadSuccessfulCount <= 0) {
            newStatus = true;
        }
        this._fileUploadRequired = newStatus;
    }
    checkFileLimit(newFilesLength) {
        let activeFileCount = 0;
        this.value.forEach((file) => {
            if (file.active) {
                activeFileCount++;
            }
        });
        if (this.fileLimit > 0 && ((activeFileCount + newFilesLength) > this.fileLimit)) {
            const message = this.translationService.getText("FileLimitMessage", String(this.fileLimit));
            this.getForm().getApp().yesNo(message, () => { }, () => { });
            return false;
        }
        return true;
    }
    checkFileSize(files) {
        if (this._singleFileSizeLimit || this._allFilesSizeLimit) {
            // check single file limit
            let sizeSum = 0;
            const fileArray = Array.from(files);
            for (const file of fileArray) {
                sizeSum += file.size;
                if (this._singleFileSizeLimit > 0 && file.size > this._singleFileSizeLimit) {
                    const message = this.translationService.getText("FileSingleSizeMessage", this.getReadableFileSizeString(this._singleFileSizeLimit));
                    this.getForm().getApp().yesNo(message, () => { }, () => { });
                    return false;
                }
            }
            // check sum limit
            if (this._allFilesSizeLimit > 0) {
                this.value.forEach((file) => {
                    if (file.active) {
                        sizeSum += file.size;
                    }
                });
                if (this._allFilesSizeLimit > 0 && sizeSum > this._allFilesSizeLimit) {
                    const message = this.translationService.getText("FileAllSizeMessage", this.getReadableFileSizeString(this._allFilesSizeLimit));
                    this.getForm().getApp().yesNo(message, () => { }, () => { });
                    return false;
                }
            }
        }
        return true;
    }
    getReadableFileSizeString(byteSize) {
        let i = -1;
        const byteUnits = [" kB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
        do {
            byteSize = byteSize / 1024;
            i++;
        } while (byteSize > 1024);
        return Math.max(byteSize, 0.1).toFixed(1) + byteUnits[i];
    }
    download(key) {
        window.location.assign(this.getForm().getApp().getBackendUrl() + this.url + "/" + key.key);
    }
    fromJson(modelFormField) {
        super.fromJson(modelFormField);
        this.type = "fileUpload";
        if (modelFormField["url"]) {
            this.url = modelFormField["url"];
        }
        if (modelFormField["multiple"] != null) {
            this.multiple = modelFormField["multiple"];
        }
        if (modelFormField["acceptedFileTypes"]) {
            this.acceptedFileTypes = modelFormField["acceptedFileTypes"];
        }
        if (modelFormField["fileLimit"]) {
            this._fileLimit = modelFormField["fileLimit"];
        }
        if (modelFormField["singleFileSizeLimit"]) {
            this._singleFileSizeLimit = modelFormField["singleFileSizeLimit"];
        }
        if (modelFormField["allFilesSizeLimit"]) {
            this._allFilesSizeLimit = modelFormField["allFilesSizeLimit"];
        }
        this.updateRequiredStatus();
    }
}
class PathFile {
    constructor() {
        this.uploadFinished = false;
        this.uploadSuccessful = false;
        this.uploadProgress = 0;
        this.size = 0;
    }
}
// TODO unify with list key
// tslint:disable:max-classes-per-file
class PathFileKey {
    constructor(key, name) {
        this.key = key;
        this.name = name;
    }
    equals(otherKey) {
        if (otherKey != null &&
            otherKey.name &&
            otherKey.key &&
            this.name &&
            this.key &&
            otherKey.name === this.name &&
            otherKey.key === this.key) {
            return true;
        }
        return false;
    }
}

let FieldListFieldComponent = class FieldListFieldComponent {
};
__decorate([
    Input("field"),
    Output("field")
], FieldListFieldComponent.prototype, "field", void 0);
FieldListFieldComponent = __decorate([
    Component({
        selector: "path-field-list",
        template: "<span *ngFor=\"let label of field.subfields;\">\r\n    <path-label-field [field]=\"label\"></path-label-field>\r\n</span>"
    })
], FieldListFieldComponent);
class FieldListField extends ValueField {
    constructor() {
        super(...arguments);
        this._subfields = [];
    }
    get subfields() {
        return this._subfields;
    }
    set subfields(value) {
        this._subfields = value;
    }
}

class FocusUtility {
    static focusFirstField(currentForm) {
        window.setTimeout(() => {
            let focusDone = false;
            let forms = document.forms;
            if (currentForm != null) {
                forms = [forms[forms.length - 1]]; // only last form on form stack
            }
            for (const form of forms) {
                for (const element of form.elements) {
                    if (element instanceof HTMLInputElement &&
                        element.type === "text" || element.type === "textarea") {
                        const input = element;
                        if (input.outerHTML.indexOf("readonly-with-required") < 0) { // no focus on readonly fields
                            input.focus();
                            focusDone = true;
                        }
                        break;
                    }
                }
                if (focusDone) {
                    break;
                }
            }
        }, 1);
    }
}

let FormComponent = class FormComponent {
    onSubmit() {
        this.form.close(true, false);
    }
    ngAfterViewInit() {
        FocusUtility.focusFirstField(this.form);
    }
};
__decorate([
    Input("form"),
    Output("form")
], FormComponent.prototype, "form", void 0);
FormComponent = __decorate([
    Component({
        selector: "path-form",
        template: "<div [ngClass]=\"form.borderStyle == 2 ? 'modal-content' : ''\">\r\n\t<form (ngSubmit)=\"onSubmit()\" #pathForm=\"ngForm\" autocomplete=\"off\" ngNativeValidate>\r\n\t\t<div *ngIf=\"form.headerVisible\" class=\"modal-header\">\r\n\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" (click)=\"form.close(false,false)\">&times;</button>\r\n\t\t\t<h5 class=\"modal-title\">{{form.title}}</h5>\r\n\t\t</div>\r\n\t\t<div class=\"modal-body\">\r\n\t\t\t<div *ngFor='let row of form.rows;' class=\"row\" [hidden]=\"!row.isVisible()\">\r\n\t\t\t\t<div *ngFor='let field of row.fields;' [hidden]=\"!field.visible\">\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'text'\">\r\n\t\t\t\t\t\t<path-textfield [field]=\"field\"></path-textfield>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'translation'\">\r\n\t\t\t\t\t\t<path-translationfield [field]=\"field\"></path-translationfield>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'number'\">\r\n\t\t\t\t\t\t<path-numberfield [field]=\"field\"></path-numberfield>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'label'\">\r\n\t\t\t\t\t\t<path-label-field [field]=\"field\"></path-label-field>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'fieldList'\">\r\n\t\t\t\t\t\t<path-field-list [field]=\"field\"></path-field-list>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'date'\">\r\n\t\t\t\t\t\t<path-datefield [field]=\"field\"></path-datefield>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'autocomplete'\">\r\n\t\t\t\t\t\t<path-autocomplete [field]=\"field\"></path-autocomplete>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'ProgressBarField'\">\r\n\t\t\t\t\t\t<path-progress-bar [field]=\"field\"></path-progress-bar>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'RadioGroupField'\">\r\n\t\t\t\t\t\t<path-radio-group [field]=\"field\"></path-radio-group>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'CheckboxGroupField'\">\r\n\t\t\t\t\t\t<path-checkbox-group [field]=\"field\"></path-checkbox-group>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div *ngIf=\"field.type == 'fileUpload'\">\r\n\t\t\t\t\t\t<path-file-upload [field]=\"field\"></path-file-upload>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t\t<!-- show form buttons on modal-body in mobile version, otherwise they are taking up too much space when the keyboard is shown -->\r\n\t\t\t<div [hidden]=\"!form.footerVisible\" class=\"hide-on-desktop\">\r\n\t\t\t\t<div class=\"row\">\r\n                    <div class=\"col-md-12\">\r\n\t\t\t\t\t<div class=\"col-md-2 buttons-smartphone-left\">\r\n\t\t\t\t\t<span *ngFor='let field of form.fields' class=\"pull-left\" [hidden]=\"!field.visible\">\r\n\t\t\t\t\t\t<span *ngIf=\"field.type == 'deleteButton'\">\r\n\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"button\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t<span *ngIf=\"field.type == 'previousButton'\">\r\n\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"button\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t\t</span>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"col-md-10 buttons-smartphone-right\">\r\n\t\t\t\t\t<span *ngFor='let field of form.fields' [hidden]=\"!field.visible\">\r\n\t\t\t\t\t\t<span *ngIf=\"field.type == 'okButton'\">\r\n\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"submit\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t<span *ngIf=\"field.type == 'cancelButton'\">\r\n\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"button\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t\t</span>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n                </div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<!-- default version for desktop devices -->\r\n\t\t<div class=\"hide-on-mobile\">\r\n\t\t\t<div [hidden]=\"!form.footerVisible\" class=\"modal-footer\">\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-md-2\">\r\n\t\t\t\t\t\t<span *ngFor='let field of form.fields' class=\"pull-left\" [hidden]=\"!field.visible\">\r\n\t\t\t\t\t\t\t<span *ngIf=\"field.type == 'deleteButton'\">\r\n\t\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"button\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t\t<span *ngIf=\"field.type == 'previousButton'\">\r\n\t\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"button\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"col-md-10\">\r\n\t\t\t\t\t\t<span *ngFor='let field of form.fields' [hidden]=\"!field.visible\">\r\n\t\t\t\t\t\t\t<span *ngIf=\"field.type == 'okButton'\">\r\n\t\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"submit\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t\t<span *ngIf=\"field.type == 'cancelButton'\">\r\n\t\t\t\t\t\t\t\t<input [disabled]=\"field.isReadonly()\" type=\"button\" class=\"btn btn-default btn-footer\" (click)=\"field.onClick()\" value=\"{{field.name}}\"/>\r\n\t\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</form>\r\n</div>"
    })
], FormComponent);
class Form {
    constructor(pathService, app) {
        this.pathService = pathService;
        this.app = app;
        this._fields = [];
        this._rows = [];
        this._headerVisible = true;
        this._footerVisible = true;
        this._borderStyle = BorderStyle.Shadow;
    }
    getApp() {
        return this.app;
    }
    getKey() {
        return this.key;
    }
    get key() {
        return this._key;
    }
    set key(value) {
        this._key = value;
    }
    get rows() {
        return this._rows;
    }
    get title() {
        return this._title;
    }
    set title(value) {
        this._title = value;
    }
    getFields() {
        return this.fields;
    }
    get fields() {
        return this._fields;
    }
    set fields(value) {
        this._fields = value;
    }
    get handler() {
        return this._handler;
    }
    set handler(value) {
        this._handler = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    get bean() {
        return this._bean;
    }
    set bean(value) {
        this._bean = value;
    }
    get formFunction() {
        return this._formFunction;
    }
    set formFunction(value) {
        this._formFunction = value;
    }
    get headerVisible() {
        return this._headerVisible;
    }
    set headerVisible(value) {
        this._headerVisible = value;
    }
    get footerVisible() {
        return this._footerVisible;
    }
    set footerVisible(value) {
        this._footerVisible = value;
    }
    get borderStyle() {
        return this._borderStyle;
    }
    set borderStyle(value) {
        this._borderStyle = value;
    }
    get urlDefaults() {
        return this._urlDefaults;
    }
    fromJson(modelForm) {
        this.url = modelForm["url"];
        if (modelForm["urlDefaults"] != null) {
            this._urlDefaults = modelForm["urlDefaults"];
        }
        this.headerVisible = true;
        if (modelForm["headerVisible"] != null) {
            this.headerVisible = modelForm["headerVisible"];
        }
        this.footerVisible = true;
        if (modelForm["footerVisible"] != null) {
            this.footerVisible = modelForm["footerVisible"];
        }
        this.borderStyle = BorderStyle.Shadow;
        if (modelForm["borderStyle"] != null) {
            const borderStyleString = modelForm["borderStyle"];
            this.borderStyle = BorderStyle[borderStyleString];
        }
    }
    updateRows() {
        const rows = [];
        let currentFormRow;
        for (const field of this.fields) {
            if (field instanceof FieldListField) {
                for (const subField of field.subfields) {
                    currentFormRow = this.calculateFieldRow(subField, currentFormRow, rows);
                    currentFormRow.fields.push(subField);
                }
            }
            else {
                currentFormRow = this.calculateFieldRow(field, currentFormRow, rows);
                currentFormRow.fields.push(field);
            }
        }
        this._rows = rows;
    }
    calculateFieldRow(field, currentFormRow, rows) {
        // auto-start new row with form width 2
        if (currentFormRow == null ||
            field.newRow ||
            currentFormRow.fields.length >= 2 ||
            field.width >= 2 ||
            currentFormRow.getWidth() >= 2) {
            field.newRow = true;
            currentFormRow = new FormRow();
            rows.push(currentFormRow);
        }
        return currentFormRow;
    }
    close(save, remove) {
        if (save || remove) {
            // call close handler
            if (this.handler != null) {
                this.handler.doSave(this._bean);
            }
            const data = {};
            for (const field of this._fields) {
                if (field instanceof ValueField && field.id != null) {
                    data[field.id] = field.value;
                }
                if (field instanceof FieldListField) {
                    for (const subfield of field.subfields) {
                        data[subfield.id] = subfield.value;
                    }
                }
            }
            if (remove) {
                this.pathService.serverDelete(this.app.getBackendUrl(), this.url, this.formFunction.delete);
            }
            else if (this.key == null) {
                // create
                this.pathService.serverPost(this.app.getBackendUrl(), this.url, data, this.formFunction.save, null);
            }
            else {
                // update (with key)
                this.pathService.serverPut(this.app.getBackendUrl(), this.url, data, this.formFunction.save);
            }
        }
        else {
            this.formFunction.cancel();
        }
    }
    onKey(event) {
        if (event.keyCode === 27) { // esc
            this.close(false, false);
        }
    }
}
class FormRow {
    constructor() {
        this._fields = [];
    }
    get fields() {
        return this._fields;
    }
    set fields(value) {
        this._fields = value;
    }
    getWidth() {
        let sum = 0;
        for (const field of this.fields) {
            sum += field.width;
        }
        return sum;
    }
    isVisible() {
        for (const field of this.fields) {
            if (field.visible) {
                return true;
            }
        }
        return false;
    }
}
var BorderStyle;
(function (BorderStyle) {
    // TODO use string enum after TS upgrade, then use enum in template (with member)
    BorderStyle[BorderStyle["None"] = 1] = "None";
    BorderStyle[BorderStyle["Shadow"] = 2] = "Shadow";
})(BorderStyle || (BorderStyle = {}));

class KeyUtility {
    static translateUrl(url, formKey, crudFormUrl, parentPageElement) {
        let translatedUrl = url;
        if (translatedUrl != null) {
            if (formKey != null && !(translatedUrl.indexOf(formKey.getName()) > 0) && crudFormUrl) {
                translatedUrl = translatedUrl + "/" + formKey.getKey();
            }
            if (formKey != null) {
                translatedUrl = translatedUrl.replace(":" + formKey.getName(), formKey.getKey());
            }
            let pageElement = parentPageElement;
            while (pageElement != null) {
                if (pageElement.getKey() != null) {
                    translatedUrl = translatedUrl.replace(":" + pageElement.getKey().getName(), pageElement.getKey().getKey());
                }
                pageElement = pageElement.getParent();
            }
        }
        return translatedUrl;
    }
    static findKey(pageElement, name) {
        let searchKeyName = name;
        if (searchKeyName) {
            searchKeyName = searchKeyName.replace(":", "");
            while (pageElement != null) {
                if (pageElement.getKey() != null && pageElement.getKey().getName() === searchKeyName) {
                    return pageElement.getKey();
                }
                pageElement = pageElement.getParent();
            }
        }
        return null;
    }
    static replaceVariable(url, variable, value) {
        // replace variables at line end
        let regExp = new RegExp(":" + variable + "$", "g");
        url = url.replace(regExp, value);
        // replace variables in middle of line
        regExp = new RegExp(":" + variable + "\/", "g");
        url = url.replace(regExp, value + "/");
        return url;
    }
    static variableExists(url, variable) {
        const regExp = new RegExp(":" + variable + "$", "g");
        const regExp2 = new RegExp(":" + variable + "\/", "g");
        return url.search(regExp) !== -1 || url.search(regExp2) !== -1;
    }
}

class PageElement {
    constructor(app) {
        this._visible = true;
        this._newRow = false;
        this._listElement = false;
        this._app = app;
    }
    static buildShortName(str) {
        if (str == null || str.length === 0) {
            return "";
        }
        if (str.length > 63) {
            return str.substr(0, 60) + "...";
        }
        return str;
    }
    getShortName() {
        return PageElement.buildShortName(this.name);
    }
    get app() {
        return this._app;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
    }
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    get width() {
        return this._width;
    }
    set width(value) {
        this._width = value;
    }
    getKey() {
        return this._key;
    }
    get key() {
        return this._key;
    }
    set key(value) {
        this._key = value;
    }
    getParent() {
        return this.parentPageElement;
    }
    get visible() {
        return this._visible;
    }
    set visible(value) {
        this._visible = value;
    }
    get newRow() {
        return this._newRow;
    }
    set newRow(value) {
        this._newRow = value;
    }
    get parentPageElement() {
        return this._parentPageElement;
    }
    set parentPageElement(value) {
        this._parentPageElement = value;
    }
    get listElement() {
        return this._listElement;
    }
    set listElement(value) {
        this._listElement = value;
    }
    fromJson(modelElement) {
        this.visible = true;
        if (modelElement["id"] != null) {
            this.id = modelElement["id"];
        }
        if (modelElement["key"] != null) {
            const name = modelElement["key"]["name"];
            if (name && !modelElement["key"]["key"]) {
                this.key = KeyUtility.findKey(this.parentPageElement, name);
            }
            else {
                this.key = new Key(modelElement["key"]["key"], name);
            }
        }
        if (modelElement["visible"] != null) {
            this.visible = modelElement["visible"];
        }
        if (modelElement["newRow"] != null) {
            this.newRow = modelElement["newRow"];
        }
        if (modelElement["width"] != null) {
            this.width = modelElement["width"];
        }
        else {
            this.width = 1;
        }
    }
}
class Key {
    constructor(key, name) {
        this._key = key;
        this._name = name;
    }
    getName() {
        return this._name;
    }
    set key(value) {
        this._key = value;
    }
    getKey() {
        return this._key;
    }
    set name(value) {
        this._name = value;
    }
    equals(otherKey) {
        if (otherKey != null &&
            otherKey.getName() &&
            otherKey.getKey() &&
            this.getName() &&
            this.getKey() &&
            otherKey.getName() === this.getName() &&
            otherKey.getKey() === this.getKey()) {
            return true;
        }
        return false;
    }
}

let ButtonGroupComponent = class ButtonGroupComponent {
};
__decorate([
    Input("buttonGroup"),
    Output("buttonGroup")
], ButtonGroupComponent.prototype, "buttonGroup", void 0);
ButtonGroupComponent = __decorate([
    Component({
        selector: "path-button-group",
        template: "<span>\r\n    <div *ngIf='buttonGroup.mobilePageBreak' class=\"tile-group tile-group-divider tile hide-on-desktop\"></div>\r\n    <div *ngIf='buttonGroup.visible' class=\"tile-group\">\r\n            <span *ngFor='let pageElement of buttonGroup.buttons'>\r\n            <!-- Button -->\r\n            <span *ngIf='pageElement.type == \"button\" || pageElement.type == \"newButton\"'>\r\n                <path-button [button]=\"pageElement\"></path-button>\r\n            </span>\r\n            <!-- Back Button -->\r\n            <span *ngIf='pageElement.type == \"backbutton\"'>\r\n                <path-back-button [button]=\"pageElement\"></path-back-button>\r\n            </span>\r\n            <!-- Delete Button -->\r\n            <span *ngIf='pageElement.type == \"deleteButton\"'>\r\n                <path-page-delete-button [button]=\"pageElement\"></path-page-delete-button>\r\n            </span>\r\n            <!-- Link Button (deprecated: DownloadButton -->\r\n            <span *ngIf='pageElement.type == \"linkButton\" || pageElement.type == \"downloadButton\"'>\r\n                <path-link-button [button]=\"pageElement\"></path-link-button>\r\n            </span>\r\n        </span>\r\n    </div>\r\n    <div *ngIf='buttonGroup.mobilePageBreak' class=\"tile-group tile-group-divider tile hide-on-desktop\"></div>\r\n</span>"
    })
], ButtonGroupComponent);
class ButtonGroup extends PageElement {
    constructor(app) {
        super(app);
        this._buttons = [];
        this._mobilePageBreak = false;
    }
    get buttons() {
        return this._buttons;
    }
    get mobilePageBreak() {
        return this._mobilePageBreak;
    }
    addButton(button) {
        this._buttons.push(button);
        let length = 0;
        for (const currentButton of this.buttons) {
            length += (currentButton.width >= 2 ? 2 : 1);
        }
        this._mobilePageBreak = length > 1 && this.buttons.length >= 2;
    }
    updateButtonBorders() {
        if (this._buttons.length === 1) {
            // single button has no special border
            this._buttons[0].cssGroupBorder = "";
        }
        else {
            for (const button of this._buttons) {
                button.cssGroupBorder = "tile-grouped-middle";
            }
            if (this._buttons.length >= 1) {
                // set first and last button border
                this._buttons[0].cssGroupBorder = "tile-grouped-left";
                this._buttons[this._buttons.length - 1].cssGroupBorder = "tile-grouped-right";
            }
        }
    }
    fromJson(modelElement) {
        super.fromJson(modelElement);
        this.type = "buttonGroup";
    }
}

// Note: Chart would be an example for a custom path element contributed by a path user
let ChartComponent = class ChartComponent {
    ngAfterViewInit() {
        this.chart.load((data) => {
            this.chart.data = data;
        });
    }
};
__decorate([
    Input("chart"),
    Output("chart")
], ChartComponent.prototype, "chart", void 0);
ChartComponent = __decorate([
    Component({
        selector: "path-radar-chart",
        template: "<div *ngIf=\"chart.data != null\">\r\n\t<div class=\"panel panel-default\">\r\n\t\t<div class=\"panel-heading\">\r\n\t\t\t<h3 class=\"panel-title\">{{chart.data?.name}}</h3>\r\n\t\t</div>\r\n\t\t<div class=\"panel-body\">\r\n\t\t\t<p>{{chart.data?.customer}}</p>\r\n\t\t\t<p *ngIf=\"chart.data?.referenceProjectCount >= 0\">{{chart.translationService.getText(\"ReferencedProjects\")}}: {{chart.data?.referenceProjectCount}}</p>\r\n\t\t</div>\r\n\r\n\t\t<table *ngIf=\"chart.data?.interviewees?.list.length > 0\" class=\"table\">\r\n\t\t\t<tr>\r\n\t\t\t\t<th>{{chart.translationService.getText(\"Salutation\")}}<th>\r\n\t\t\t\t<th>{{chart.translationService.getText(\"Interviewees\")}}<th>\r\n\t\t\t\t<th>{{chart.translationService.getText(\"EmploymentTitle\")}}<th>\r\n\t\t\t</tr>\r\n\t\t\t<tr *ngFor=\"let interviewee of chart.data?.interviewees?.list\">\r\n\t\t\t\t<td>{{interviewee.salutation}}<td>\r\n\t\t\t\t<td>{{interviewee.name}}<td>\r\n\t\t\t\t<td>{{interviewee.employmentTitle}}<td>\r\n\t\t\t</tr>\r\n\t\t</table>\r\n\t</div>\r\n\r\n\t<div class=\"panel panel-default\" *ngFor=\"let category of chart.data?.categoryResults?.list\" width=\"100%\">\r\n\t\t<div class=\"panel-heading\">\r\n\t\t\t<h3 class=\"panel-title\">{{category.name}}</h3>\r\n\t\t</div>\r\n\t\t<div class=\"panel-body\">\r\n\t\t\t<p align=\"center\">\r\n\t\t\t\t<img *ngIf=\"category.spider != null\" width=\"600\" src=\"data:image/png;base64,{{category.spider}}\"/>\r\n\t\t\t\t<img *ngIf=\"category.stackedBar != null\" width=\"600\" src=\"data:image/png;base64,{{category.stackedBar}}\"/>\r\n\t\t\t</p>\r\n\t\t</div>\r\n\t\t<table class=\"table\">\r\n\t\t\t<tr>\r\n\t\t\t\t<th class=\"col-md-9\">{{chart.translationService.getText(\"Question\")}}<th>\r\n\t\t\t\t<th class=\"col-md-1 text-right\">{{chart.translationService.getText(\"Actual\")}}<th>\r\n\t\t\t\t<th class=\"col-md-1 text-right\">{{chart.translationService.getText(\"Target\")}}<th>\r\n\t\t\t\t<th class=\"col-md-1 text-right\">Gap<th>\r\n\t\t\t</tr>\r\n\t\t\t<tr *ngFor=\"let question of category.questions.list\">\r\n\t\t\t\t<td>{{question.name}}<td>\r\n\t\t\t\t<td class=\"text-right\">{{question.actualValue}}<td>\r\n\t\t\t\t<td class=\"text-right\">{{question.targetValue}}<td>\r\n\t\t\t\t<td class=\"text-right\">{{question.gap}}<td>\r\n\t\t\t</tr>\r\n\t\t</table>\r\n\r\n\t</div>\r\n\r\n\t<div *ngIf=\"chart.data?.notCalculatedKPIs?.list.length > 0\" class=\"panel panel-default\" width=\"100%\">\r\n\t\t<div class=\"panel-heading\">\r\n\t\t\t<h3 class=\"panel-title\">Not calculated KPIs</h3>\r\n\t\t</div>\r\n\t\t<table class=\"table\">\r\n\t\t\t<tr *ngFor=\"let kpi of chart.data?.notCalculatedKPIs?.list\">\r\n\t\t\t\t<td>{{kpi.name}}<td>\r\n\t\t\t</tr>\r\n\t\t</table>\r\n\r\n\t</div>\r\n\r\n\t<div class=\"panel panel-default\" *ngFor=\"let kpi of chart.data?.calculatedKPIs?.list\" width=\"100%\">\r\n\t\t<div class=\"panel-heading\">\r\n\t\t\t<h3 class=\"panel-title\">{{kpi.name}}</h3>\r\n\t\t</div>\r\n\t\t<div class=\"panel-body\">\r\n\t\t\t<p align=\"center\">\r\n\t\t\t\t<img width=\"300\" src=\"data:image/png;base64,{{kpi.dial}}\"/>\r\n\t\t\t</p>\r\n\t\t</div>\r\n\t\t<table class=\"table\">\r\n\t\t\t<tr>\r\n\t\t\t\t<th class=\"col-md-8\" >KPI<th>\r\n\t\t\t\t<th class=\"col-md-1\" class=\"text-right\">\r\n\t\t\t\t\t<span *ngIf=\"kpi.optimalValue == 'Maximum'\">{{chart.translationService.getText(\"WorstValue\")}}</span>\r\n\t\t\t\t\t<span *ngIf=\"kpi.optimalValue == 'Minimum'\">{{chart.translationService.getText(\"BestValue\")}}</span>\r\n\t\t\t\t\t<span *ngIf=\"kpi.optimalValue == 'Neutral'\">Min</span>\r\n\t\t\t\t<th>\r\n\t\t\t\t<th class=\"col-md-1\" class=\"text-right\">{{chart.translationService.getText(\"OwnValue\")}}<th>\r\n\t\t\t\t<th class=\"col-md-1\" class=\"text-right\">\r\n\t\t\t\t<span *ngIf=\"kpi.optimalValue == 'Maximum'\">{{chart.translationService.getText(\"BestValue\")}}</span>\r\n\t\t\t\t<span *ngIf=\"kpi.optimalValue == 'Minimum'\">{{chart.translationService.getText(\"WorstValue\")}}</span>\r\n\t\t\t\t\t<span *ngIf=\"kpi.optimalValue == 'Neutral'\">Max</span>\r\n\t\t\t\t<th>\r\n\t\t\t\t<th class=\"col-md-1\" class=\"text-right\">Ranking<th>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>{{kpi.name}}<td>\r\n\t\t\t\t<td class=\"text-right\">{{kpi.min}}<td>\r\n\t\t\t\t<td class=\"text-right\">{{kpi.value}}<td>\r\n\t\t\t\t<td class=\"text-right\">{{kpi.max}}<td>\r\n\t\t\t\t<td class=\"text-right\">{{kpi.ranking}}<td>\r\n\t\t\t</tr>\r\n\t\t</table>\r\n\r\n\t</div>\r\n\r\n</div>"
    })
], ChartComponent);
class ChartElement extends PageElement {
    constructor(app, pathService, translationService) {
        super(app);
        this.pathService = pathService;
        this.translationService = translationService;
    }
    load(loader) {
        this.pathService.serverGet(this.app.getBackendUrl(), this.url, loader, (err) => {
            console.log("error" + err);
        });
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value;
    }
}

class AutoCompleteFieldEntry {
    get key() {
        return this._key;
    }
    set key(value) {
        this._key = value;
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
    }
    get active() {
        return this._active;
    }
    set active(value) {
        this._active = value;
    }
}

class FormFunction {
    get cancel() {
        return this._cancel;
    }
    set cancel(value) {
        this._cancel = value;
    }
    get save() {
        return this._save;
    }
    set save(value) {
        this._save = value;
    }
    get delete() {
        return this._delete;
    }
    set delete(value) {
        this._delete = value;
    }
}

let AutoCompleteComponent = class AutoCompleteComponent {
    constructor(myElement) {
        this._elementRef = myElement;
    }
    handleClick(event) {
        if (this.field.isReadonly()) {
            return;
        }
        let clickedComponent = event.target;
        let inside = false;
        do {
            if (clickedComponent === this._elementRef.nativeElement) {
                inside = true;
            }
            clickedComponent = clickedComponent.parentNode;
        } while (clickedComponent);
        if (!inside) {
            this.field.clearFilteredList();
        }
        if (!this.field.valueSet) {
            this.field.query = null;
            this.field.setValue(null);
        }
    }
};
AutoCompleteComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input("field"),
    Output("field")
], AutoCompleteComponent.prototype, "field", void 0);
AutoCompleteComponent = __decorate([
    Component({
        selector: "path-autocomplete",
        // tslint:disable-next-line
        host: {
            "(document:click)": "handleClick($event)",
        },
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n    <div class=\"input-group\">\r\n        <input #model=\"ngModel\" [readonly]=\"field.isReadonly()\"\r\n               [class.required-field]=\"(!model.valid &&!model.pristine && field.required)\" [required]=\"field.required\"\r\n               #inputElement type=\"text\" [ngModel]=field.query?.text (keyup)=field.filter(inputElement.value,$event)\r\n               (blur)=\"field.focusLost()\" class=\"form-control\" placeholder=\"\">\r\n        <!-- Auto Complete -->\r\n        <div *ngIf=\"field.filteredList.length > 0 && !field.isReadonly()\">\r\n            <div class=\"path-autocomplete list-group\">\r\n                <a *ngFor=\"let item of field.filteredList\" class=\"list-group-item\" href=\"#\"\r\n                   (click)=\"field.select(item)\"><h5>{{item.text}}</h5></a>\r\n            </div>\r\n        </div>\r\n        <!-- Action -->\r\n        <span *ngIf=\"field.detailForm != null\" class=\"input-group-btn\">\r\n                <button (click)=\"field.showDetailForm()\" class=\"btn btn-default\" type=\"button\">{{field.getDetailButtonName()}}</button>\r\n            </span>\r\n    </div>\r\n</div>\r\n"
    })
], AutoCompleteComponent);
class AutoCompleteField extends ValueField {
    constructor(form, translationService, pathService) {
        super(form, translationService);
        this.form = form;
        this.translationService = translationService;
        this.pathService = pathService;
        this._filteredList = [];
        this._data = [];
        this._dataLoaded = false;
        this._valueSet = false;
    }
    isReadonly() {
        return super.isReadonly() && this.isInitialValueSet;
    }
    filter(query, event) {
        // do not filter readonly fields
        if (this.isReadonly()) {
            return;
        }
        // do not filter on simple tab focus change
        if (event.keyCode === 9) {
            return;
        }
        this._valueSet = false;
        if (query !== null && query.length > 0 && query.replace(/\s/g, "").length === 0) {
            /* space: all */
            this._filteredList = this._data.filter(function (entry) {
                return entry.active;
            }.bind(this));
        }
        else if (query !== null && query !== "") {
            /* search term: filter */
            query = query.trim();
            this._filteredList = this._data.filter(function (entry) {
                if (!entry.active) {
                    return false;
                }
                const entryName = entry.text;
                if (entryName.toLowerCase().indexOf(query.toLowerCase()) > -1) {
                    return true;
                }
                else if (this._wordSearchEnabled) {
                    const tokens = entryName.toLowerCase().split(" ");
                    for (const token of tokens) {
                        if (token.startsWith(query.toLowerCase())) {
                            return true;
                        }
                    }
                }
                return false;
            }.bind(this));
        }
        else {
            /* empty: nothing */
            this.clearFilteredList();
        }
        this._filteredList.sort();
    }
    select(item) {
        this.setValue(item.key);
    }
    focusLost() {
        window.setTimeout(() => {
            if (!this.valueSet) {
                // force angular to update query.text value
                if (this.value == null) {
                    this.resetDisplay(null);
                }
                else {
                    this.resetDisplay(this.value["key"]);
                }
            }
        }, 1);
    }
    setValue(value) {
        const oldValue = this.value;
        // accept key values and complex objects
        if (value != null && value["key"] != null) {
            value = value["key"];
            this._keyType = value["name"];
        }
        this._valueSet = value != null;
        this.clearFilteredList();
        super.setValue(value);
        this.query = null;
        this.resetDisplay(value);
        // reload dependent autocomplete fields
        if (oldValue !== this.value) {
            for (const field of this.getForm().getFields()) {
                if (field instanceof AutoCompleteField) {
                    if (field.id !== this.id) {
                        const autoCompleteField = field;
                        if (KeyUtility.variableExists(autoCompleteField.url, this.id)) {
                            autoCompleteField.load();
                        }
                    }
                }
            }
        }
    }
    load() {
        this.dataLoaded = false;
        let url = this.url;
        for (const field of this.getForm().getFields()) {
            if (field instanceof ValueField) {
                const valueField = field;
                url = KeyUtility.replaceVariable(url, valueField.id, valueField.value);
                console.log(url);
            }
        }
        this.pathService.serverGet(this.getForm().getApp().getBackendUrl(), url, (data) => {
            const dynamicData = [];
            for (const item of data) {
                const entry = new AutoCompleteFieldEntry();
                entry.key = item["key"]["key"];
                entry.text = item["name"];
                if (item["active"] != null) {
                    entry.active = item["active"];
                }
                else {
                    entry.active = true;
                }
                dynamicData.push(entry);
            }
            this.data = dynamicData;
            this.dataLoaded = true;
            this.setValue(this.value); // force display refresh
        }, null);
    }
    getDetailButtonName() {
        if (this.value == null) {
            return this.translationService.getText("New") + "...";
        }
        else {
            return this.translationService.getText("Detail") + "...";
        }
    }
    showDetailForm() {
        let form = null;
        const formFunction = new FormFunction();
        formFunction.save = (data) => {
            this.getForm().getApp().closeCurrentForm();
            if (data["key"] != null) {
                this.setValue(data["key"]);
            }
            this.load();
        };
        formFunction.cancel = () => {
            this.getForm().getApp().closeCurrentForm();
        };
        formFunction.delete = (data) => {
            this.getForm().getApp().closeCurrentForm();
            this.setValue(null);
            this.load();
        };
        if (this.value == null) {
            form = this.getForm().getApp().createForm(this.detailForm, null, null, formFunction, null);
        }
        else {
            form = this.getForm().getApp().createForm(this.detailForm, new Key(this.value, this._keyType), null, formFunction, null);
        }
        this.form.getApp()["_formStack"].push(form); // TODO
    }
    clearFilteredList() {
        this._filteredList = [];
    }
    resetDisplay(value) {
        // must wait with display update until data is loaded
        const displaySetter = () => {
            const keyValue = value;
            if (!this.dataLoaded) {
                console.log("waiting...");
                window.setTimeout(function () {
                    displaySetter();
                }, 250);
            }
            else {
                if (keyValue == null) {
                    window.setTimeout(() => {
                        // check value again, may have changed since reset was triggered
                        if (this.value == null) {
                            this.query = new AutoCompleteFieldEntry();
                        }
                    }, 1);
                }
                else {
                    for (const item of this._data) {
                        // tslint:disable:triple-equals
                        if (item.key == keyValue) {
                            window.setTimeout(() => {
                                this.query = item;
                            }, 1);
                            break;
                        }
                    }
                }
            }
        };
        displaySetter();
    }
    get query() {
        return this._query;
    }
    set query(value) {
        this._query = value;
    }
    set data(value) {
        this._data = value;
    }
    get filteredList() {
        return this._filteredList;
    }
    set wordSearchEnabled(value) {
        this._wordSearchEnabled = value;
    }
    get valueSet() {
        return this._valueSet;
    }
    get dataLoaded() {
        return this._dataLoaded;
    }
    set dataLoaded(value) {
        this._dataLoaded = value;
    }
    get detailForm() {
        return this._detailForm;
    }
    set detailForm(value) {
        this._detailForm = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
}

let TextFieldComponent = class TextFieldComponent {
};
__decorate([
    Input("field"),
    Output("field")
], TextFieldComponent.prototype, "field", void 0);
TextFieldComponent = __decorate([
    Component({
        selector: "path-textfield",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n    <div class=\"input-group\">\r\n        <input *ngIf=\"!field.isPassword && (field.height == null || field.height <= 1)\" #model=\"ngModel\" [readonly]=\"field.isReadonly()\" [class.required-field]=\"(!model.valid &&!model.pristine && field.required)\" [required]=\"field.required\" [(ngModel)]=field.value [attr.maxlength]=\"field.maxLength\" type=\"text\" class=\"form-control\" placeholder=\"\">\r\n        <textarea *ngIf=\"!field.isPassword && (field.height != null && field.height > 1)\" #model=\"ngModel\" [readonly]=\"field.isReadonly()\" [class.required-field]=\"(!model.valid &&!model.pristine && field.required)\" [required]=\"field.required\" [(ngModel)]=field.value rows=\"{{field.height}}\" [attr.maxlength]=\"field.maxLength\" type=\"text\" class=\"form-control\" placeholder=\"\"></textarea>\r\n        <input *ngIf=\"field.isPassword\" #model=\"ngModel\" [readonly]=\"field.isReadonly()\" [class.required-field]=\"(!model.valid &&!model.pristine && field.required)\" [required]=\"field.required\" [(ngModel)]=field.value [attr.maxlength]=\"field.maxLength\" type=\"password\" class=\"form-control\" placeholder=\"\">\r\n    </div>\r\n</div>\r\n"
    })
], TextFieldComponent);
class TextField extends ValueField {
    constructor() {
        super(...arguments);
        this._isPassword = false;
        this._maxLength = 250;
    }
    get isPassword() {
        return this._isPassword;
    }
    set isPassword(value) {
        this._isPassword = value;
    }
    get maxLength() {
        return this._maxLength;
    }
    set maxLength(value) {
        this._maxLength = value;
    }
    fromJson(modelFormField) {
        super.fromJson(modelFormField);
        if (modelFormField["isPassword"] != null) {
            this.isPassword = (modelFormField["isPassword"]);
        }
        if (modelFormField["maxLength"] != null) {
            this.maxLength = (modelFormField["maxLength"]);
        }
    }
}

const moment = momentImported;
let DateFieldComponent = class DateFieldComponent {
};
__decorate([
    Input("field"),
    Output("field")
], DateFieldComponent.prototype, "field", void 0);
DateFieldComponent = __decorate([
    Component({
        selector: "path-datefield",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n    <div class=\"input-group\">\r\n\t    <span class=\"input-group-btn\">\r\n\t\t    <button (click)=\"datepicker.toggle()\" class=\"btn btn-default\" type=\"button\"><i class=\"fa fa-calendar fa-fw\"></i></button>\r\n\t    </span>\r\n\t    <input #datepicker=\"bsDatepicker\" #model=\"ngModel\" bsDatepicker [bsConfig]=\"{ dateInputFormat: field.dateInputFormat, containerClass: 'theme-default' }\" placement=\"bottom left\" [bsValue]=\"field.datePickerInitialValue\" [(ngModel)]=\"field.datePickerValue\" (bsValueChange)=\"field.updateValueFromGui($event)\" [isDisabled]=\"field.isReadonly()\" [readonly]=\"field.isReadonly()\" [class.required-field]=\"(!model.valid &&!model.pristine && field.required)\" [required]=\"field.required\" style=\"display: block; width: 100%\" type=\"text\" class=\"form-control\" placeholder=\"\">\r\n    </div>\r\n</div>\r\n"
    })
], DateFieldComponent);
class DateField extends ValueField {
    constructor(form, translationService) {
        super(form, translationService);
        this.form = form;
        this.translationService = translationService;
        this._initialValueSet = false;
        this._dateInputFormat = translationService.getUserDateFormat();
    }
    get datePickerValue() {
        return this._datePickerValue;
    }
    set datePickerValue(value) {
        this._datePickerValue = value;
    }
    get initialValueSet() {
        return this._initialValueSet;
    }
    get datePickerInitialValue() {
        return this._datePickerInitialValue;
    }
    get dateInputFormat() {
        return this._dateInputFormat;
    }
    setValue(value) {
        if (typeof value === "string") {
            value = moment(value).toDate();
        }
        if (value != null && Object.prototype.toString.call(value) === "[object Date]") {
            // it is a date
            if (isNaN(value.getTime())) {
                value = null;
            }
            else {
                // cut off local timezone
                value = new Date(value.toDateString() + " 00:00:00 GMT");
            }
        }
        else {
            value = null;
        }
        // update ui
        this._datePickerValue = value;
        super.setValue(value);
        if (!this._initialValueSet) {
            this._datePickerInitialValue = value;
            this._initialValueSet = true;
        }
    }
    updateValueFromGui(value) {
        if (value != null && isNaN(value.getDate())) {
            value = null;
        }
        if (value != null) {
            this.setValue(value);
            this._datePickerValue = this.value;
        }
    }
}

class Radio extends FormField {
    get key() {
        return this._key;
    }
    set key(value) {
        this._key = value;
    }
}

let RadioGroupComponent = class RadioGroupComponent {
};
__decorate([
    Input("field"),
    Output("field")
], RadioGroupComponent.prototype, "field", void 0);
RadioGroupComponent = __decorate([
    Component({
        selector: "path-radio-group",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n\t<div [ngClass]=\"{'radio': field.horizontal}\">\r\n        <span *ngFor='let radioElement of field.radios' [ngClass]=\"{'radio': !field.horizontal}\">\r\n            <label>\r\n                <input #radio name=\"{{field.id}}\" [(ngModel)]=\"field.value\" (click)=\"field.updateValueFromGui(radioElement.key)\" [value]=\"radioElement.key.toString()\" [disabled]=\"field.isReadonly()\" type=\"radio\">\r\n                <span> {{radioElement.name}}&nbsp;&nbsp;</span>\r\n            </label>\r\n        </span>\r\n\t</div>\r\n</div>\r\n"
    })
], RadioGroupComponent);
class RadioGroupField extends ValueField {
    constructor() {
        super(...arguments);
        this._radios = [];
    }
    get radios() {
        return this._radios;
    }
    set radios(value) {
        this._radios = value;
    }
    get horizontal() {
        return this._horizontal;
    }
    set horizontal(value) {
        this._horizontal = value;
    }
    setValue(value) {
        if (value != null) {
            value = value.toString();
        }
        super.setValue(value);
    }
    updateValueFromGui(value) {
        this.setValue(value.toString());
    }
    isReadonly() {
        return super.isReadonly() && this.isInitialValueSet;
    }
    fromJson(modelFormField) {
        super.fromJson(modelFormField);
        this._horizontal = true;
        if (modelFormField["alignment"] != null) {
            if (modelFormField["alignment"] === "vertical") {
                this._horizontal = false;
            }
        }
        if (modelFormField["radios"] != null) {
            for (const radioModel of modelFormField["radios"]) {
                const radio = new Radio(this.getForm(), this.translationService);
                radio.name = radioModel.name;
                radio.key = radioModel.key;
                if (radio.key === modelFormField["defaultKey"]) {
                    this.setValue(radio.key);
                }
                this.radios.push(radio);
            }
        }
    }
}

let CheckboxGroupComponent = class CheckboxGroupComponent {
};
__decorate([
    Input("field"),
    Output("field")
], CheckboxGroupComponent.prototype, "field", void 0);
CheckboxGroupComponent = __decorate([
    Component({
        selector: "path-checkbox-group",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div class=\"checkbox\" [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n    <span *ngFor=\"let entry of field.entries\">\r\n        <label class=\"checkbox-inline\">\r\n            <input type=\"checkbox\" [(ngModel)]=\"entry.selected\" (ngModelChange)=\"field.doClick()\">\r\n            <span class=\"checkbox-label\"> {{entry.name}}&nbsp;&nbsp;</span>\r\n        </label>\r\n    </span>\r\n</div>\r\n"
    })
], CheckboxGroupComponent);
class CheckboxGroupField extends ValueField {
    constructor() {
        super(...arguments);
        this._entries = [];
    }
    get entries() {
        return this._entries;
    }
    set entries(value) {
        this._entries = value;
    }
    doClick() {
        const values = [];
        for (const entry of this.entries) {
            if (entry.selected) {
                values.push(entry.key);
            }
        }
        this.setValue(values);
    }
    setValue(values) {
        super.setValue(values);
        for (const entry of this.entries) {
            entry.selected = false;
        }
        for (const value of values) {
            for (const entry of this.entries) {
                if (entry.key === value) {
                    entry.selected = true;
                }
            }
        }
    }
    fromJson(modelFormField) {
        super.fromJson(modelFormField);
        for (const entryModel of modelFormField["data"]) {
            const entry = new CheckboxGroupEntry();
            entry.name = entryModel.name;
            entry.key = entryModel.key;
            entry.selected = false;
            this.entries.push(entry);
        }
    }
}
class CheckboxGroupEntry {
    get key() {
        return this._key;
    }
    set key(value) {
        this._key = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get selected() {
        return this._selected;
    }
    set selected(value) {
        this._selected = value;
    }
}

let FormFieldLabelComponent = class FormFieldLabelComponent {
};
__decorate([
    Input("label")
], FormFieldLabelComponent.prototype, "label", void 0);
__decorate([
    Input("required")
], FormFieldLabelComponent.prototype, "required", void 0);
FormFieldLabelComponent = __decorate([
    Component({
        selector: "path-form-field-label",
        template: "<div class=\"col-md-2\">\r\n    <h5 class=\"modal-title\" [class.required]=\"required\">{{label}}</h5>\r\n</div>\r\n"
    })
], FormFieldLabelComponent);

let ProgressBarComponent = class ProgressBarComponent {
};
__decorate([
    Input("field"),
    Output("field")
], ProgressBarComponent.prototype, "field", void 0);
ProgressBarComponent = __decorate([
    Component({
        selector: "path-progress-bar",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n    <div class=\"progress progress-striped\">\r\n        <div class=\"progress-bar\" role=\"progressbar\" [style.width.%]=\"field.value\" [attr.aria-valuenow]=\"field.value\" aria-valuemin=\"0\" aria-valuemax=\"100\">\r\n            <span class=\"sr-only\">{{field.value}}% Complete</span>\r\n        </div>\r\n    </div>\r\n</div>\r\n"
    })
], ProgressBarComponent);
class ProgressBarField extends ValueField {
    fromJson(modelFormField) {
        super.fromJson(modelFormField);
        this.setValue(modelFormField["value"]);
    }
}

let LabelFieldComponent = class LabelFieldComponent {
};
__decorate([
    Input("field"),
    Output("field")
], LabelFieldComponent.prototype, "field", void 0);
LabelFieldComponent = __decorate([
    Component({
        selector: "path-label-field",
        template: "<path-form-field-label [hidden]=\"!field.labelVisible\" [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.labelVisible\" [class.col-md-6]=\"!field.labelVisible\">\r\n    <h5 class=\"modal-title\"><div [innerHTML]=\"field.value\"></div></h5>\r\n</div>"
    })
], LabelFieldComponent);
class LabelField extends ValueField {
}

let NumberFieldComponent = class NumberFieldComponent {
};
__decorate([
    Input("field"),
    Output("field")
], NumberFieldComponent.prototype, "field", void 0);
NumberFieldComponent = __decorate([
    Component({
        selector: "path-numberfield",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n    <div class=\"input-group\">\r\n        <input min=\"{{field.min}}\" max=\"{{field.max}}\" step=\"{{field.getStep()}}\" *ngIf=\"field.height == null || field.height <= 1\" #model=\"ngModel\" [readonly]=\"field.isReadonly()\" [class.required-field]=\"(!model.valid &&!model.pristine && field.required)\" [required]=\"field.required\" [(ngModel)]=field.value type=\"number\" class=\"form-control\" placeholder=\"\">\r\n    </div>\r\n</div>\r\n"
    })
], NumberFieldComponent);
class NumberField extends ValueField {
    get min() {
        return this._min;
    }
    set min(value) {
        this._min = value;
    }
    get max() {
        return this._max;
    }
    set max(value) {
        this._max = value;
    }
    get digits() {
        return this._digits;
    }
    set digits(value) {
        this._digits = value;
    }
    getStep() {
        if (this._digits == null) {
            return "";
        }
        else if (this._digits === 0) {
            return "0";
        }
        // e.g. 3 => 0.001
        let step = "0.";
        for (let k = 0; k < this._digits - 1; k++) {
            step = step + "0";
        }
        return step + "1";
    }
    fromJson(modelFormField) {
        super.fromJson(modelFormField);
        if (modelFormField["min"] != null) {
            this.min = modelFormField["min"];
        }
        if (modelFormField["max"] != null) {
            this.max = modelFormField["max"];
        }
        if (modelFormField["digits"] != null) {
            this.digits = modelFormField["digits"];
        }
    }
}

class OkButton extends FormField {
    get handler() {
        return this._handler;
    }
    set handler(value) {
        this._handler = value;
    }
    onClick() {
        if (this._handler != null) {
            this._handler.doClick(null); // TODO
        }
        // closing/saving is done in submit function on form component
    }
}

class CancelButton extends FormField {
    get handler() {
        return this._handler;
    }
    set handler(value) {
        this._handler = value;
    }
    onClick() {
        if (this._handler != null) {
            this._handler.doClick(null); // TODO
        }
        this.form.close(false, false);
    }
}

let TranslationFieldComponent = class TranslationFieldComponent {
};
__decorate([
    Input("field"),
    Output("field")
], TranslationFieldComponent.prototype, "field", void 0);
TranslationFieldComponent = __decorate([
    Component({
        selector: "path-translationfield",
        template: "<path-form-field-label [label]=\"field.name\" [required]=\"field.required\"></path-form-field-label>\r\n<div [class.col-md-4]=\"field.width == 1\" [class.col-md-10]=\"field.width == 2\">\r\n    <div class=\"input-group\">\r\n        <input *ngIf=\"field.height == null || field.height <= 1\" #model=\"ngModel\" readonly-with-required (keydown)=\"field.editTranslations()\" (click)=\"field.editTranslations()\" [class.required-field]=\"!model.valid && !model.pristine && field.required\" [required]=\"field.required\" [(ngModel)]=\"field.defaultTranslation\" type=\"text\" class=\"form-control\" placeholder=\"\">\r\n        <textarea *ngIf=\"field.height != null && field.height > 1\" #model=\"ngModel\" readonly-with-required (keydown)=\"field.editTranslations()\" (click)=\"field.editTranslations()\" [class.required-field]=\"(!model.valid &&!model.pristine && field.required)\" [required]=\"field.required\" [(ngModel)]=field.defaultTranslation rows=\"{{field.height}}\" type=\"text\" class=\"form-control\" placeholder=\"\"></textarea>\r\n        <span class=\"input-group-btn\">\r\n                <button [disabled]=\"field.isReadonly()\" (click)=\"field.editTranslations()\" class=\"btn btn-default\" type=\"button\">{{field.translationLabel}}...</button>\r\n        </span>\r\n    </div>\r\n</div>\r\n"
    })
], TranslationFieldComponent);
class TranslationField extends ValueField {
    constructor(form, pathService, translationService) {
        super(form, translationService);
        this.pathService = pathService;
        this.translationService = translationService;
        this._defaultTranslation = null;
        this.userLanguage = translationService.getUserLanguage();
        this.languages = translationService.getSupportedLanguageCodes();
        const initialList = [];
        for (const language of this.languages) {
            initialList.push([{ "key": language }, ""]);
        }
        this.setValue(initialList);
        this._translationLabel = translationService.getText("Translation");
    }
    get defaultTranslation() {
        return this._defaultTranslation;
    }
    set defaultTranslation(value) {
        this._defaultTranslation = value;
    }
    get translationLabel() {
        return this._translationLabel;
    }
    setValue(value) {
        super.setValue(value);
        this._defaultTranslation = this.getDefaultTranslation();
    }
    getDefaultTranslation() {
        if (this.value != null) {
            for (const item of this.value) {
                if (item[0] != null && item[0]["key"] === this.userLanguage) {
                    return item[1];
                }
            }
        }
        return null;
    }
    editTranslations() {
        const form = new Form(this.pathService, this.form.getApp());
        const translationFields = [];
        form.title = this.name + " " + this.translationService.getText("Translations");
        form.formFunction = new FormFunction();
        form.formFunction.save = (data) => {
            const resultList = [];
            for (const field of translationFields) {
                resultList.push([{ "key": field.id }, field.value]);
            }
            this.setValue(resultList);
            this.getForm().getApp().closeCurrentForm();
        };
        form.formFunction.cancel = () => {
            this.getForm().getApp().closeCurrentForm();
        };
        const translations = this.value;
        for (const key of translations) {
            const textField = new TextField(form, this.translationService);
            textField.type = "text";
            textField.id = key[0]["key"];
            textField.name = this.translationService.getText(key[0]["key"]);
            textField.visible = true;
            textField.newRow = true;
            textField.width = 2;
            textField.height = this.height;
            textField.labelVisible = true;
            textField.required = true;
            textField.setValue(key[1]);
            form.fields.push(textField);
            translationFields.push(textField);
        }
        const cancelButton = new CancelButton(form, this.translationService);
        cancelButton.type = "cancelButton";
        cancelButton.name = this.translationService.getText("Cancel");
        cancelButton.visible = true;
        form.fields.push(cancelButton);
        const okButton = new OkButton(form, this.translationService);
        okButton.type = "okButton";
        okButton.name = this.translationService.getText("Ok");
        okButton.visible = true;
        form.fields.push(okButton);
        form.updateRows();
        this.form.getApp()["_formStack"].push(form); // TODO
        FocusUtility.focusFirstField(form);
    }
}
class TranslationEntry {
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
    }
    get code() {
        return this._code;
    }
    set code(value) {
        this._code = value;
    }
}

// Initially by https://github.com/cedvdb/ng2draggable
// MIT License: https://github.com/cedvdb/ng2draggable/blob/master/LICENSE
let DraggableDirective = class DraggableDirective {
    constructor(element) {
        this.element = element;
        this.topStart = 0;
        this.leftStart = 0;
        this._allowDrag = true;
    }
    ngOnInit() {
        // draggable only for desktop version (styles for desktop are added when innerWidth>1100)
        if (window.innerWidth < 768) {
            this._allowDrag = false;
        }
        // css changes
        if (this._allowDrag) {
            this.element.nativeElement.style.position = "relative";
            this.element.nativeElement.className += " cursor-draggable";
        }
    }
    set allowDrag(value) {
        this._allowDrag = value;
        if (this._allowDrag) {
            this.element.nativeElement.className += " cursor-draggable";
        }
        else {
            this.element.nativeElement.className = this.element.nativeElement.className.replace(" cursor-draggable", "");
        }
    }
    onMouseDown(event) {
        const eventTargetTag = event.target["tagName"].toLowerCase();
        if (eventTargetTag === "input" || eventTargetTag === "button" || eventTargetTag === "textarea") {
            return;
        }
        if (event.button === 2) {
            return; // prevents right click drag, remove his if you don't want it
        }
        this.md = true;
        this.topStart = event.clientY - this.element.nativeElement.style.top.replace("px", "");
        this.leftStart = event.clientX - this.element.nativeElement.style.left.replace("px", "");
    }
    onMouseUp(event) {
        this.md = false;
    }
    onMouseMove(event) {
        if (this.md && this._allowDrag) {
            this.element.nativeElement.style.top = (event.clientY - this.topStart) + "px";
            this.element.nativeElement.style.left = (event.clientX - this.leftStart) + "px";
        }
    }
    onTouchStart(event) {
        this.md = true;
        this.topStart = event.changedTouches[0].clientY - this.element.nativeElement.style.top.replace("px", "");
        this.leftStart = event.changedTouches[0].clientX - this.element.nativeElement.style.left.replace("px", "");
        event.stopPropagation();
    }
    onTouchEnd() {
        this.md = false;
    }
    onTouchMove(event) {
        if (this.md && this._allowDrag) {
            this.element.nativeElement.style.top = (event.changedTouches[0].clientY - this.topStart) + "px";
            this.element.nativeElement.style.left = (event.changedTouches[0].clientX - this.leftStart) + "px";
        }
        event.stopPropagation();
    }
};
DraggableDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input("path-draggable")
], DraggableDirective.prototype, "allowDrag", null);
__decorate([
    HostListener("mousedown", ["$event"])
], DraggableDirective.prototype, "onMouseDown", null);
__decorate([
    HostListener("document:mouseup")
], DraggableDirective.prototype, "onMouseUp", null);
__decorate([
    HostListener("document:mousemove", ["$event"])
], DraggableDirective.prototype, "onMouseMove", null);
__decorate([
    HostListener("touchstart", ["$event"])
], DraggableDirective.prototype, "onTouchStart", null);
__decorate([
    HostListener("document:touchend")
], DraggableDirective.prototype, "onTouchEnd", null);
__decorate([
    HostListener("document:touchmove", ["$event"])
], DraggableDirective.prototype, "onTouchMove", null);
DraggableDirective = __decorate([
    Directive({
        selector: "[path-draggable]"
    })
], DraggableDirective);

class StringUtility {
    static isEmpty(str) {
        return (!str || 0 === str.length);
    }
}

class ButtonDetail {
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
    }
}

class ColorUtility {
    static isPathDefaultColor(color) {
        return this.colors.indexOf(color) > 0;
    }
}
ColorUtility.colors = [
    "blue",
    "green",
    "search",
    "red",
    "yellow",
    "orange",
    "pink",
    "purple",
    "lime",
    "magenta",
    "teal",
    "turquoise",
    "green-sea",
    "emerald",
    "nephritis",
    "peter-river",
    "belize-hole",
    "amethyst",
    "wisteria",
    "wet-asphalt",
    "midnight-blue",
    "sun-flower",
    "carrot",
    "pumpkin",
    "alizarin",
    "pomegranate",
    "clouds",
    "silver",
    "concrete",
    "asbestos",
    "info",
    "danger",
    "warning",
    "success"
];

let ButtonComponent = class ButtonComponent {
};
__decorate([
    Input("button"),
    Output("button")
], ButtonComponent.prototype, "button", void 0);
ButtonComponent = __decorate([
    Component({
        selector: "path-button",
        template: "<a (click)=\"button.onClick()\" class=\"fa-links\">\r\n\t<div tooltip=\"{{button.tooltip}}\" *ngIf=\"button.visible\" class=\"thumbnail tile {{button.cssButtonTarget ? 'tile-button' : ''}} {{(button.width <= 1 ? 'tile-medium' : (button.width == 2 ? 'tile-wide' : (button.width == 3 ? 'tile-wide-3' : (button.width >= 4 ? 'tile-wide-4' : ''))))}} {{button.cssGroupBorder}} {{button.cssClass}}\" [ngStyle]=\"button.cssStyle\">\r\n\t\t<div class=\"h3 truncate\">{{button.name}}</div>\r\n\t\t<span class=\"truncate\" *ngFor='let detail of button.details; let last = last;'>\r\n                    <span class=\"h4 m-t-5\" [innerHTML]=\"detail.text\"></span><small [hidden]=\"last\">&nbsp;&bull;&nbsp;</small></span>\r\n\t\t<div class=\"h4 m-t-5\"></div>\r\n\t\t<i class=\"fa fa-2x {{button.icon}}\"></i>\r\n\t</div>\r\n</a>\r\n"
    })
], ButtonComponent);
class Button extends PageElement {
    constructor(app, pathService, translationService) {
        super(app);
        this.pathService = pathService;
        this.translationService = translationService;
        this._details = [];
    }
    onClick() {
        if (this._handler != null) {
            this._handler.doClick(this);
            return;
        }
        if (!StringUtility.isEmpty(this._url)) {
            this.pathService.serverGet(this.app.getBackendUrl(), this._url, () => {
                this.app.refreshCurrentPage();
            }, null);
        }
        if (!StringUtility.isEmpty(this._page)) {
            this.app.setCurrentPage(this._page, this);
            return;
        }
        if (!StringUtility.isEmpty(this._form)) {
            this.app.setCurrentForm(this._form, this.key, this._formHandler, this);
            return;
        }
    }
    setIcon(icon) {
        this.icon = icon;
    }
    setForm(form) {
        this.form = form;
    }
    setFormHandler(formHandler) {
        this.formHandler = formHandler;
    }
    setPage(page) {
        this.page = page;
    }
    setKey(key) {
        this.key = key;
    }
    getApp() {
        return this.app;
    }
    getName() {
        return this.name;
    }
    get icon() {
        return this._icon;
    }
    set icon(value) {
        this._icon = value;
    }
    get cssStyle() {
        return this._cssStyle;
    }
    get cssClass() {
        return this._cssClass;
    }
    get cssButtonTarget() {
        return this._cssButtonTarget;
    }
    get cssGroupBorder() {
        return this._cssGroupBorder;
    }
    set cssGroupBorder(value) {
        this._cssGroupBorder = value;
    }
    get handler() {
        return this._handler;
    }
    set handler(value) {
        this._handler = value;
    }
    get details() {
        return this._details;
    }
    set details(value) {
        this._details = value;
    }
    get page() {
        return this._page;
    }
    set page(value) {
        this._page = value;
    }
    get form() {
        return this._form;
    }
    set form(value) {
        this._form = value;
    }
    get formHandler() {
        return this._formHandler;
    }
    set formHandler(value) {
        this._formHandler = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    get tooltip() {
        return this._tooltip;
    }
    set tooltip(value) {
        this._tooltip = value;
    }
    fromJson(modelElement) {
        super.fromJson(modelElement);
        // general attributes
        this.type = "button";
        this.setIcon(modelElement["icon"]);
        if (modelElement["color"] != null) {
            const color = modelElement["color"];
            if (typeof color === "object") {
                this._cssStyle = color;
            }
            else if (typeof color === "string") {
                if (ColorUtility.isPathDefaultColor(color)) {
                    this._cssClass = "tile-" + color;
                }
                else {
                    this._cssClass = color;
                }
            }
        }
        if (modelElement["form"] != null) {
            this.setForm(modelElement["form"]["form"]);
            this.setFormHandler(modelElement["form"]["handler"]);
        }
        this.setPage(modelElement["page"]);
        if (this.key == null && this.parentPageElement != null && modelElement.type === "button") {
            this.key = this.parentPageElement.key;
        }
        this.name = this.translationService.getText(modelElement["name"]);
        this.url = KeyUtility.translateUrl(modelElement["url"], null, false, this);
        if (modelElement["tooltip"] != null) {
            this.tooltip = this.translationService.getText(modelElement["tooltip"]);
        }
        // button details
        if (modelElement["details"] != null) {
            this.details = [];
            for (const detail of modelElement["details"]) {
                const bd = new ButtonDetail();
                bd.text = detail;
                this.details.push(bd);
            }
        }
        // button target
        this._cssButtonTarget = true;
        if (this.type === "button") {
            if (StringUtility.isEmpty(this.form) && StringUtility.isEmpty(this.page) && StringUtility.isEmpty(this.url)) {
                this._cssButtonTarget = false;
            }
        }
    }
}

let BackButtonComponent = class BackButtonComponent {
};
__decorate([
    Input("button"),
    Output("button")
], BackButtonComponent.prototype, "button", void 0);
BackButtonComponent = __decorate([
    Component({
        selector: "path-back-button",
        template: "<a (click)=\"button.onClick()\" class=\"fa-links\">\r\n\t<div class=\"thumbnail tile tile-button {{(button.width <= 1 ? 'tile-medium' : (button.width == 2 ? 'tile-wide' : (button.width == 3 ? 'tile-wide-3' : (button.width >= 4 ? 'tile-wide-4' : ''))))}} backbutton {{button.cssGroupBorder}} {{button.cssClass}}\" [ngStyle]=\"button.cssStyle\">\r\n\t\t<div class=\"h3\">{{button.name}}</div>\r\n\t\t<i class=\"fa fa-2x fa-backward\"></i>\r\n\t</div>\r\n</a>"
    })
], BackButtonComponent);
class BackButton extends Button {
    constructor(app, pathService, translationService) {
        super(app, pathService, translationService);
    }
    onClick() {
        this.app.navigateBack();
    }
    fromJson(modelElement) {
        if (StringUtility.isEmpty(modelElement["color"])) {
            modelElement["color"] = "silver";
        }
        super.fromJson(modelElement);
        this.type = "backbutton";
        this.name = this.translationService.getText("Back");
    }
}

let LinkButtonComponent = class LinkButtonComponent {
};
__decorate([
    Input("button"),
    Output("button")
], LinkButtonComponent.prototype, "button", void 0);
LinkButtonComponent = __decorate([
    Component({
        selector: "path-link-button",
        template: "<a (click)=\"button.onClick()\" class=\"fa-links\">\r\n\t<div class=\"thumbnail tile tile-button {{(button.width <= 1 ? 'tile-medium' : (button.width == 2 ? 'tile-wide' : (button.width == 3 ? 'tile-wide-3' : (button.width >= 4 ? 'tile-wide-4' : ''))))}} col-md-3 {{button.cssGroupBorder}} {{button.cssClass}}\" [ngStyle]=\"button.cssStyle\">\r\n\t\t<div class=\"h3\">{{button.name}}</div>\r\n\t\t<i class=\"fa fa-2x {{button.icon}}\"></i>\r\n\t</div>\r\n</a>\r\n\r\n\r\n"
    })
], LinkButtonComponent);
class LinkButton extends Button {
    constructor(app, pathService, translationService) {
        super(app, pathService, translationService);
    }
    onClick() {
        let url = null;
        if (this.url.startsWith("/")) {
            // local relative url
            url = this.getApp().getBackendUrl() + this.url + "?token=" + sessionStorage.getItem("pathAppId");
        }
        else {
            // remote absolute url
            url = this.url;
        }
        window.location.assign(url);
    }
    fromJson(modelElement) {
        super.fromJson(modelElement);
        this.type = "linkButton";
        this.url = KeyUtility.translateUrl(modelElement["url"], null, false, this.parentPageElement);
    }
}

let PageDeleteButtonComponent = class PageDeleteButtonComponent {
};
__decorate([
    Input("button"),
    Output("button")
], PageDeleteButtonComponent.prototype, "button", void 0);
PageDeleteButtonComponent = __decorate([
    Component({
        selector: "path-page-delete-button",
        template: "<a (click)=\"button.onClick()\" class=\"fa-links\">\r\n\t<div class=\"thumbnail tile tile-button {{(button.width <= 1 ? 'tile-medium' : (button.width == 2 ? 'tile-wide' : (button.width == 3 ? 'tile-wide-3' : (button.width >= 4 ? 'tile-wide-4' : ''))))}} tile-red col-md-3 {{button.cssGroupBorder}} {{button.cssClass}}\" [ngStyle]=\"button.cssStyle\">\r\n\t\t<div class=\"h3\">{{button.name}}</div>\r\n\t\t<i class=\"fa fa-2x fa-remove\"></i>\r\n\t</div>\r\n</a>\r\n"
    })
], PageDeleteButtonComponent);
class PageDeleteButton extends Button {
    constructor(app, pathService, translationService) {
        super(app, pathService, translationService);
        this.name = translationService.getText("Delete");
    }
    onClick() {
        this.getApp().yesNo(this.translationService.getText("DeleteWarningQuestion"), () => {
            this.pathService.serverDelete(this.getApp().getBackendUrl(), this.url, () => {
                this.getApp().navigateBack();
                this.getApp().refreshCurrentPage();
            });
        }, () => {
        });
    }
    fromJson(modelElement) {
        super.fromJson(modelElement);
        this.type = "deleteButton";
        this.url = KeyUtility.translateUrl(modelElement["url"], null, false, this.parentPageElement);
    }
}

let PageLabelComponent = class PageLabelComponent {
};
__decorate([
    Input("pageLabel"),
    Output("pageLabel")
], PageLabelComponent.prototype, "pageLabel", void 0);
PageLabelComponent = __decorate([
    Component({
        selector: "path-page-label",
        template: "<div class=\"col-md-12\" [innerHTML]=\"pageLabel.value\"></div>"
    })
], PageLabelComponent);
class PageLabel extends PageElement {
    constructor(app, pathService, translationService) {
        super(app);
    }
    get value() {
        return this._value;
    }
    onClick() {
        this.app.navigateBack();
    }
    fromJson(modelElement) {
        super.fromJson(modelElement);
        this.type = "pageLabel";
        if (modelElement["value"] != null) {
            this._value = modelElement["value"];
        }
    }
}

let ListComponent = class ListComponent {
    ngAfterViewInit() {
        FocusUtility.focusFirstField(null);
    }
};
__decorate([
    Input("list"),
    Output("list")
], ListComponent.prototype, "list", void 0);
ListComponent = __decorate([
    Component({
        selector: "path-list",
        template: "<!-- search on mobile devices -->\r\n<div *ngIf='list.search' class=\"search-mobile hide-on-desktop\">\r\n    <div class=\"row\">\r\n        <label for=\"search-mobile\">Search</label>\r\n        <input id=\"search-mobile\" name=\"search\" [(ngModel)]=\"list.searchText\" placeholder=\"{{list.searchInputLabel}}\" (ngModelChange)='list.filterChanged($event)' class=\"form-control\" type=\"text\">\r\n    </div>\r\n</div>\r\n<span>\r\n    <span>\r\n        <div class=\"tile-group\">\r\n            <!-- default search (tablet, desktop) -->\r\n            <div *ngIf='list.search' class=\"thumbnail {{(list.searchButton.width <= 1 ? 'tile-medium' : (list.searchButton.width == 2 ? 'tile-wide' : (list.searchButton.width == 3 ? 'tile-wide-3' : (list.searchButton.width >= 4 ? 'tile-wide-4' : ''))))}} tile tile-button hide-on-mobile {{list.searchButton.cssClass}}\" [ngStyle]=\"list.searchButton.cssStyle\">\r\n                <div class=\"input-group input-group-sm\">\r\n                    <div class=\"h3\">{{list.searchLabel}}</div>\r\n                    <i class=\"fa fa-2x fa-search\"></i>\r\n                    <div class=\"h5\"></div>\r\n                    <form>\r\n                        <input name=\"search\" [(ngModel)]=\"list.searchText\" placeholder=\"{{list.searchInputLabel}}\" (ngModelChange)='list.filterChanged($event)' class=\"form-control\" type=\"text\">\r\n                    </form>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </span>\r\n    <!-- list -->\r\n    <span *ngFor='let buttonGroup of list.buttonGroups; let i = index'>\r\n        <path-button-group [buttonGroup]=\"buttonGroup\"></path-button-group>\r\n    </span>\r\n</span>"
    })
], ListComponent);
class List extends PageElement {
    constructor(app, pathService, translationService) {
        super(app);
        this.pathService = pathService;
        this.translationService = translationService;
        this._buttonGroups = [];
        this._searchTextChanged = new Subject();
        this._searchLabel = translationService.getText("Search");
        this._searchInputLabel = translationService.getText("SearchInputLabel");
        this._searchButton = new Button(app, pathService, translationService);
    }
    getContent() {
        const buttons = [];
        for (const buttonGroup of this.buttonGroups) {
            buttons.push(...buttonGroup.buttons);
        }
        return buttons;
    }
    refresh(searchText, afterRefreshHandler) {
        // callback function for data
        console.log("refresh list (searchText: " + searchText + ")");
        const dataHandler = (data) => {
            this.buttonGroups = [];
            for (const item of data) {
                // create button group and buttons
                // set default types if server does not set type (button or buttonGroup)
                const itemIsButtonGroup = item.hasOwnProperty("buttons");
                if (itemIsButtonGroup) {
                    item["type"] = "buttonGroup";
                    for (const button of item.buttons) {
                        if (button["type"] == null) {
                            button["type"] = "button";
                        }
                    }
                }
                else {
                    if (item["type"] == null) {
                        item["type"] = "button";
                    }
                }
                const pageElements = this.app.createPageElement(item, this.parentPageElement, null);
                if (pageElements.length !== 1) {
                    console.log("error creating button group from: ");
                    console.log(item);
                }
                else {
                    const buttonGroup = pageElements[0];
                    let buttonCounter = 0;
                    for (const button of buttonGroup.buttons) {
                        button.listElement = true;
                        // model is either simple button or button of a group
                        let buttonModel = item;
                        if (itemIsButtonGroup) {
                            buttonModel = item.buttons[buttonCounter];
                        }
                        // build button from json
                        // use list defaults if button does not specify model
                        if (buttonModel["icon"] == null) {
                            buttonModel["icon"] = this.icon;
                        }
                        if (buttonModel["color"] == null) {
                            buttonModel["color"] = this.color;
                        }
                        if (buttonModel["page"] == null && (buttonModel["form"] == null || buttonModel["form"]["form"] == null)) {
                            // service does not return page or form, use static model
                            if (this.page != null) {
                                buttonModel["page"] = this.page;
                            }
                            if (this.form != null) {
                                buttonModel["form"] = {};
                                buttonModel.form["form"] = this.form;
                                buttonModel.form["handler"] = this.formHandler;
                            }
                        }
                        // special default width (2 instead of 1) for buttons in list
                        if (buttonModel["width"] == null) {
                            buttonModel["width"] = this.width;
                        }
                        button.fromJson(buttonModel);
                        // special values for list buttons
                        button.handler = this._buttonHandler;
                        button.name = buttonModel.name; // no translation
                        button.tooltip = buttonModel.tooltip; // no translation
                        buttonCounter++;
                    }
                    this.buttonGroups.push(buttonGroup);
                }
            }
            if (this.handler != null) {
                this.handler.doLoad(this); // TODO useful?
            }
            // refresh search
            this.filterVisibleButtonGroups();
            if (this.limit) {
                this.setSearchResultsCountMessage();
            }
            if (afterRefreshHandler != null) {
                window.setTimeout(() => {
                    afterRefreshHandler();
                }, 1);
            }
        };
        const listHandlerDoLoad = (list) => (data) => dataHandler(data);
        // backend data
        if (this._url != null) {
            let urlParameters = "";
            if (this.searchRequest || this.limit) {
                urlParameters = "?search=" + (searchText == null ? "" : encodeURI(searchText)) + "&limit=" + this.limit;
            }
            this.pathService.serverGet(this.app.getBackendUrl(), this.url + urlParameters, listHandlerDoLoad(this), null);
        }
        // mock data
        if (this._mockData != null) {
            let count = 0;
            // fake a key for mock data
            for (const mock of this.mockData) {
                count++;
                if (mock["key"] == null) {
                    mock["key"] = count;
                }
            }
            dataHandler(this.mockData);
        }
    }
    filterChanged(text) {
        this._searchTextChanged.next(text);
    }
    filter() {
        this._searchLabel = this.translationService.getText("Search");
        if (this._searchText && this._searchText === "*") {
            this.refresh(null, null);
        }
        else if (this.searchRequest) {
            // call server to filter data
            if (!this._searchText && this.searchRequired) {
                this._buttonGroups = [];
            }
            else if (this._searchText === "*" || (!this._searchText && !this.searchRequired)) {
                this.refresh(null, null);
            }
            else if (this._searchText && this._searchText.length >= 2) {
                this.refresh(this._searchText, null);
            }
            else {
                this._searchLabel = this.translationService.getText("SearchTextTooShort");
                this._buttonGroups = [];
            }
        }
        else {
            // filter loaded data only
            this.filterVisibleButtonGroups();
        }
    }
    filterVisibleButtonGroups() {
        const searchText = this._searchText ? this._searchText.toLowerCase() : "";
        for (const buttonGroup of this._buttonGroups) {
            if (searchText.length <= 0) {
                buttonGroup.visible = true;
            }
            else {
                buttonGroup.visible = false;
                for (const button of buttonGroup.buttons) {
                    if (!buttonGroup.visible) {
                        buttonGroup.visible = button.name.toLowerCase().indexOf(searchText) !== -1;
                        if (!buttonGroup.visible) {
                            for (const detail of button.details) {
                                if (detail.text.toLowerCase().indexOf(searchText) !== -1) {
                                    buttonGroup.visible = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (this.visibleItemSize() !== this.buttonGroups.length) {
            this.setSearchResultsCountMessage();
        }
    }
    setSearchResultsCountMessage() {
        this._searchLabel = this.visibleItemSize() + " " +
            (this.visibleItemSize() === 1 ? this.translationService.getText("Result") : this.translationService.getText("Results"));
    }
    visibleItemSize() {
        let result = 0;
        for (const buttonGroup of this.buttonGroups) {
            if (buttonGroup.visible) {
                for (const button of buttonGroup.buttons) {
                    if (button.visible) {
                        result++;
                        break;
                    }
                }
            }
        }
        return result;
    }
    get buttonGroups() {
        return this._buttonGroups;
    }
    set buttonGroups(value) {
        this._buttonGroups = value;
    }
    get search() {
        return this._search;
    }
    set search(value) {
        this._search = value;
    }
    get handler() {
        return this._handler;
    }
    set handler(value) {
        this._handler = value;
    }
    get buttonHandler() {
        return this._buttonHandler;
    }
    set buttonHandler(value) {
        this._buttonHandler = value;
    }
    get icon() {
        return this._icon;
    }
    set icon(value) {
        this._icon = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    get form() {
        return this._form;
    }
    set form(value) {
        this._form = value;
    }
    get formHandler() {
        return this._formHandler;
    }
    set formHandler(value) {
        this._formHandler = value;
    }
    get page() {
        return this._page;
    }
    set page(value) {
        this._page = value;
    }
    get mockData() {
        return this._mockData;
    }
    set mockData(value) {
        this._mockData = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    get limit() {
        return this._limit;
    }
    set limit(value) {
        this._limit = value;
    }
    get searchRequired() {
        return this._searchRequired;
    }
    get searchRequest() {
        return this._searchRequest;
    }
    get searchText() {
        return this._searchText;
    }
    get searchLabel() {
        return this._searchLabel;
    }
    get searchInputLabel() {
        return this._searchInputLabel;
    }
    set searchLabel(value) {
        this._searchLabel = value;
    }
    set searchInputLabel(value) {
        this._searchInputLabel = value;
    }
    set searchText(value) {
        this._searchText = value;
    }
    get searchButton() {
        return this._searchButton;
    }
    fromJson(modelElement) {
        super.fromJson(modelElement);
        if (modelElement["search"] != null) {
            this.search = modelElement["search"];
        }
        if (modelElement["searchRequired"] != null) {
            this._searchRequired = modelElement["searchRequired"];
        }
        if (modelElement["searchRequest"] != null) {
            this._searchRequest = modelElement["searchRequest"];
        }
        if (modelElement["limit"] != null) {
            this.limit = modelElement["limit"];
        }
        // verify valid search combinations
        if (!this.search && this.searchRequired) {
            console.log("Configuration Error: search=false requires searchRequired=false");
            this._searchRequired = false;
        }
        if (this.searchRequired && !this.searchRequest) {
            console.log("Configuration Error: searchRequired=true requires searchRequest=true");
            this._searchRequest = true;
        }
        // other model attributes
        if (modelElement["color"] != null) {
            this.color = modelElement["color"];
        }
        if (modelElement["form"] != null) {
            this.form = modelElement["form"]["form"];
            this.formHandler = modelElement["form"]["handler"];
        }
        if (modelElement["page"] != null) {
            this.page = modelElement["page"];
        }
        if (modelElement["icon"] != null) {
            this.icon = modelElement["icon"];
        }
        if (modelElement["data"] != null) {
            this.mockData = modelElement["data"];
        }
        if (modelElement["name"] != null) {
            this.name = this.translationService.getText(modelElement["name"]);
        }
        if (modelElement["url"] != null) {
            const urlString = modelElement["url"];
            this.url = KeyUtility.translateUrl(urlString, null, false, this);
        }
        // override from PageElement
        if (modelElement["width"] != null) {
            this.width = modelElement["width"];
        }
        else {
            this.width = 2; // special default for list
        }
        // search button
        const searchButtonModel = {};
        searchButtonModel["color"] = modelElement["searchColor"] != null ? modelElement["searchColor"] : "tile-search";
        searchButtonModel["width"] = modelElement["searchWidth"] != null ? modelElement["searchWidth"] : this.width;
        this._searchButton.fromJson(searchButtonModel);
        // delay for search field
        const debounceTimeValue = this.searchRequest ? 300 : 30;
        this._searchTextChanged.pipe(debounceTime(debounceTimeValue)) // wait after the last event before emitting last event
            .subscribe(_searchText => {
            this._searchText = _searchText;
            this.filter();
        });
    }
}

let CustomDirective = class CustomDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
};
CustomDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
CustomDirective = __decorate([
    Directive({
        selector: "[path-custom-directive]",
    })
], CustomDirective);

let CustomContainerComponent = class CustomContainerComponent {
    constructor(componentFactoryResolver) {
        this.componentFactoryResolver = componentFactoryResolver;
    }
    ngOnInit() {
        this.loadComponent();
    }
    ngOnDestroy() {
    }
    loadComponent() {
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(this.pageElement.typeClass);
        const viewContainerRef = this.customDirective.viewContainerRef;
        viewContainerRef.clear();
        const componentRef = viewContainerRef.createComponent(componentFactory);
        componentRef.instance.pageElement = this.pageElement;
    }
};
CustomContainerComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];
__decorate([
    Input()
], CustomContainerComponent.prototype, "pageElement", void 0);
__decorate([
    ViewChild(CustomDirective, { static: true })
], CustomContainerComponent.prototype, "customDirective", void 0);
CustomContainerComponent = __decorate([
    Component({
        selector: "path-custom-container-component",
        template: `
        <ng-template path-custom-directive></ng-template>`
    })
], CustomContainerComponent);
class CustomPageElement {
    get pageElement() {
        return this._pageElement;
    }
    set pageElement(value) {
        this._pageElement = value;
    }
}

let ElementListComponent = class ElementListComponent {
};
__decorate([
    Input("elementList"),
    Output("elementList")
], ElementListComponent.prototype, "elementList", void 0);
ElementListComponent = __decorate([
    Component({
        selector: "path-element-list",
        template: "<span></span>"
    })
], ElementListComponent);
class ElementList extends PageElement {
    constructor(app, pathService, translationService) {
        super(app);
    }
    fromJson(modelElement) {
        super.fromJson(modelElement);
        this.type = "elementList";
    }
}

let BreadcrumbComponent = class BreadcrumbComponent {
};
__decorate([
    Input("app")
], BreadcrumbComponent.prototype, "app", void 0);
BreadcrumbComponent = __decorate([
    Component({
        selector: "path-breadcrumb",
        template: "<div class=\"col-md-12\">\r\n    <h3>\r\n        <ol class=\"breadcrumb\">\r\n            <li *ngFor='let page of app[\"_pageStack\"]; let currentIndex = index; let last = last'\r\n                class=\"{{last ? 'active': ''}}\">\r\n                <a class=\"invisibleSP\" href=\"#\" *ngIf='!last' (click)=\"app.navigateToPage(currentIndex)\">{{page.getShortName()}}</a>\r\n                {{last ? page.getShortName() : ''}}\r\n                &nbsp;\r\n            </li>\r\n        </ol>\r\n    </h3>\r\n</div>\r\n"
    })
], BreadcrumbComponent);
// breadcrumb is a special element since it uses app directly
class Breadcrumb extends PageElement {
    constructor(app) {
        super(app);
    }
}

var AppModule_1;
let AppModule = AppModule_1 = class AppModule {
    static forRoot() {
        return { ngModule: AppModule_1, providers: [] };
    }
};
AppModule = AppModule_1 = __decorate([
    NgModule({
        imports: [
            BrowserModule,
            HttpClientModule,
            FormsModule,
            CommonModule,
            BrowserAnimationsModule,
            BsDatepickerModule.forRoot(),
            TooltipModule.forRoot()
        ],
        declarations: [
            DraggableDirective,
            LabelFieldComponent,
            FieldListFieldComponent,
            FormComponent,
            ChartComponent,
            AutoCompleteComponent,
            ProgressBarComponent,
            TextFieldComponent,
            TranslationFieldComponent,
            NumberFieldComponent,
            DateFieldComponent,
            RadioGroupComponent,
            CheckboxGroupComponent,
            FormFieldLabelComponent,
            BackButtonComponent,
            LinkButtonComponent,
            PageDeleteButtonComponent,
            ButtonComponent,
            PageLabelComponent,
            ListComponent,
            CustomDirective,
            CustomContainerComponent,
            ElementListComponent,
            ButtonGroupComponent,
            BreadcrumbComponent,
            FileUploadComponent
        ],
        exports: [
            DraggableDirective,
            BrowserModule,
            HttpClientModule,
            FormsModule,
            CommonModule,
            BsDatepickerModule,
            TooltipModule,
            LabelFieldComponent,
            FieldListFieldComponent,
            FormComponent,
            ChartComponent,
            AutoCompleteComponent,
            ProgressBarComponent,
            TextFieldComponent,
            TranslationFieldComponent,
            NumberFieldComponent,
            DateFieldComponent,
            RadioGroupComponent,
            CheckboxGroupComponent,
            FormFieldLabelComponent,
            BackButtonComponent,
            LinkButtonComponent,
            PageDeleteButtonComponent,
            ButtonComponent,
            PageLabelComponent,
            ListComponent,
            CustomDirective,
            CustomContainerComponent,
            ElementListComponent,
            ButtonGroupComponent,
            BreadcrumbComponent,
            FileUploadComponent
        ],
    })
], AppModule);

/**
 * Generated bundle index. Do not edit.
 */

export { AppModule, DraggableDirective as a, LabelFieldComponent as b, FieldListFieldComponent as c, FormComponent as d, ChartComponent as e, AutoCompleteComponent as f, ProgressBarComponent as g, TextFieldComponent as h, TranslationFieldComponent as i, NumberFieldComponent as j, DateFieldComponent as k, RadioGroupComponent as l, CheckboxGroupComponent as m, FormFieldLabelComponent as n, BackButtonComponent as o, LinkButtonComponent as p, PageDeleteButtonComponent as q, ButtonComponent as r, PageLabelComponent as s, ListComponent as t, CustomDirective as u, CustomContainerComponent as v, ElementListComponent as w, ButtonGroupComponent as x, BreadcrumbComponent as y, FileUploadComponent as z };
//# sourceMappingURL=path-framework.js.map
